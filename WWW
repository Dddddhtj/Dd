-- Primadon LocalScript (Ù…ØµØ­Ø­ ÙˆÙ…ØªÙƒØ§Ù…Ù„)
-- Ø¶Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù ÙÙŠ StarterPlayerScripts Ø£Ùˆ ÙÙŠ Ù…ÙƒØ§Ù† LocalScript Ù…Ù†Ø§Ø³Ø¨

local _G = {
    ControllerID = 9822837105,
    CommandCooldown = {}
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local HttpService = game:GetService("HttpService")

-- ======= Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¹Ø§Ù…Ø© =======
local function isOwner(player)
    if not player then return false end
    return player.UserId == _G.ControllerID
end

local function notifyPlayer(player, message)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = "Primadon System",
            Text = message,
            Icon = "rbxassetid://0",
            Duration = 5
        })
    end)
end

local function checkCooldown(player)
    if not player then return false end
    local uid = player.UserId
    if _G.CommandCooldown[uid] and os.time() - _G.CommandCooldown[uid] < 2 then
        notifyPlayer(player, "â³ Ø§Ù†ØªØ¸Ø± 2 Ø«Ø§Ù†ÙŠØ© Ø¨ÙŠÙ† Ø§Ù„Ø£ÙˆØ§Ù…Ø±")
        return false
    end
    _G.CommandCooldown[uid] = os.time()
    return true
end

-- ======= Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø´Ø§Øª (Ù…Ø§Ù„Ùƒ ÙÙ‚Ø· ÙŠÙ…ÙƒÙ†Ù‡ ØªØ´ØºÙŠÙ„ Primadon) =======
local function processCommand(player, message)
    if not message then return end
    local command = tostring(message):lower()
    if not checkCooldown(player) then return end

    if command == "!primadon" then
        if isOwner(player) then
            -- ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³ÙƒØ±Ø¨Øª Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠ Ø¨Ø£Ù…Ø§Ù† (Ù„Ùˆ Ø£Ø±Ø¯Øª Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡)
            local ok, res = pcall(function()
                -- Ø¶Ø¹ Ø±Ø§Ø¨Ø·Ùƒ Ø£Ùˆ Ù†ÙÙ‘Ø° Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù‡Ù†Ø§. Ø¥Ù† Ù„Ù… ØªØ±Ø¯ ØªØ­Ù…ÙŠÙ„ Ø®Ø§Ø±Ø¬ÙŠØŒ Ø§Ø­Ø°Ù loadstring/HttpGet.
                -- loadstring(game:HttpGet("https://raw.githubusercontent.com/your-repo/primadon/main/script.lua"))()
                return true
            end)
            if ok then
                notifyPlayer(player, "ğŸ¦ Primadon activated!")
            else
                notifyPlayer(player, "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙØ¹ÙŠÙ„")
                warn("Primadon load error:", res)
            end
        else
            notifyPlayer(player, "âŒ ÙÙ‚Ø· Ø§Ù„Ù…Ø§Ù„Ùƒ ÙŠÙ…ÙƒÙ†Ù‡ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø±!")
        end
    end
end

local function monitorPlayer(player)
    if not player then return end
    -- ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ø­Ø¯Ø« Ù…ØªØµÙ„ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨
    player.Chatted:Connect(function(message)
        if type(message) ~= "string" then return end
        if message:sub(1,1) == "!" then
            processCommand(player, message)
        end
    end)
end

-- ÙˆØµÙ„ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ù„ÙƒÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ø­Ø§Ù„ÙŠÙŠÙ†
for _,p in ipairs(Players:GetPlayers()) do
    monitorPlayer(p)
end
Players.PlayerAdded:Connect(monitorPlayer)

-- ======= Ø§Ù†ØªØ¸Ø± LocalPlayer Ùˆ Character =======
local localPlayer = Players.LocalPlayer
if not localPlayer then
    localPlayer = Players:GetPropertyChangedSignal("LocalPlayer") and Players.LocalPlayer or nil
    if not localPlayer then
        -- ÙÙŠ Ù…Ø¹Ø¸Ù… Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø³ÙŠÙƒÙˆÙ† LocalPlayer Ø¬Ø§Ù‡Ø² Ù„Ø£Ù† Ù‡Ø°Ø§ LocalScript
        warn("LocalPlayer not found; script may not be running as LocalScript.")
    end
end

-- Ø¥Ø¹Ø·Ø§Ø¡ Ø¥Ø¹Ù„Ø§Ù… Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù„Ùˆ ÙƒØ§Ù† Ø§Ù„Ù…Ø§Ù„Ùƒ
if localPlayer and isOwner(localPlayer) then
    notifyPlayer(localPlayer, "ğŸ¦ Primadon system ready! Ø§ÙƒØªØ¨ !primadon Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©")
end

-- ======= ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ (Monky) ÙˆÙˆØ¶Ø¹Ù‡ ÙƒØ´Ø®ØµÙŠØ© Ø§Ù„Ù„Ø§Ø¹Ø¨ =======
local function safeGetObjects(assetId)
    local ok, obj = pcall(function()
        return game:GetObjects(assetId)
    end)
    if ok then return obj end
    return nil
end

local function spawnMonkyAsCharacter()
    if not localPlayer then return end
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        -- Ø§Ù†ØªØ¸Ø± Ø´Ø®ØµÙŠØ© Ø§Ù„Ù„Ø§Ø¹Ø¨
        localPlayer.CharacterAdded:Wait()
    end
    local character = localPlayer.Character
    if not character then return end

    -- ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ (ØºÙŠØ±Ù„ØµÙ‚Ù‡ asset id Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ø¥Ù† Ø§Ø­ØªØ¬Øª)
    local model = safeGetObjects("rbxassetid://17523790773")
    if not model or #model == 0 then
        warn("Failed to load model asset.")
        return
    end
    local modelInst = model[1]
    local monkyContainer = modelInst:FindFirstChild("MonkyContainer")
    local mobChar = modelInst
    if monkyContainer then
        local main = monkyContainer:FindFirstChild("Main")
        if main and main:FindFirstChild("Monky") then
            mobChar = main.Monky
        else
            -- Ø­Ø§ÙˆÙ„ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¯Ø§Ø®Ù„ monkyContainer
            local f = monkyContainer:FindFirstChildWhichIsA("Model", true)
            if f then mobChar = f end
        end
    end

    if not mobChar or not mobChar:IsA("Model") then
        warn("Monky character not found inside model.")
        return
    end

    -- Ø§Ø¬Ø¹Ù„ Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ ÙÙŠ Ø§Ù„Ù€ Workspace
    mobChar.Parent = workspace
    -- Ø§Ù†ØªØ¸Ø± Ù…ÙƒÙˆÙ†Ø§Øª Ù…Ù‡Ù…Ø©
    local humanoid = mobChar:FindFirstChildOfClass("Humanoid")
    local hrp = mobChar:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then
        warn("Monky missing Humanoid or HRP.")
        return
    end

    -- Ø¥Ø¹Ø¯Ø§Ø¯ Ø®ØµØ§Ø¦Øµ
    humanoid.MaxHealth = 999999999
    humanoid.Health = humanoid.MaxHealth
    humanoid.WalkSpeed = 32
    humanoid.JumpPower = 300
    humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None

    -- Ø­ÙØ¸ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø«Ù… ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    local oldChar = localPlayer.Character
    -- Ø¶Ø¹ Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„ ÙÙŠ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨
    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        hrp.CFrame = localPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0,40,0)
    end

    -- ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø´Ø®ØµÙŠØ© Ù„Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø­Ù„ÙŠØ§Ù‹
    localPlayer.Character = mobChar

    -- Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
    local cam = workspace.CurrentCamera
    cam.CameraSubject = humanoid
    cam.CFrame = hrp.CFrame

    -- ØªØ¯Ù…ÙŠØ± Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¨Ø£Ù…Ø§Ù† Ø¥Ù† ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
    if oldChar and oldChar ~= mobChar then
        oldChar:Destroy()
    end

    -- Ø¥Ø²Ø§Ù„Ø© MainModule Ø¥Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯ Ù„Ù…Ù†Ø¹ ØªØ¶Ø§Ø±Ø¨
    if monkyContainer then
        local mainModule = monkyContainer:FindFirstChild("MainModule")
        if mainModule then
            mainModule:Destroy()
        end
    end

    return mobChar, humanoid
end

-- Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ ÙÙˆØ±ÙŠØ§Ù‹ Ù„Ùˆ ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø£Ù…Ø± Ø£Ùˆ Ø¹Ù†Ø¯ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªØ´ØºÙŠÙ„ Ø¥Ù† Ø£Ø±Ø¯Øª Ù‡Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©:
-- spawnMonkyAsCharacter()  -- Ù„Ø§ ØªØ´ØºÙ„Ù‡ Ù…Ø§ Ù„Ù… ØªÙƒÙ† ØªØ±ÙŠØ¯ Ø§Ù„ØªØ­ÙˆÙŠÙ„ ÙÙˆØ±Ø§Ù‹ Ø¹Ù†Ø¯ Ø§Ù„ØªØ´ØºÙŠÙ„

-- ======= FRAMEWORK Ù„Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù† (Ù…ØµØ­Ø­) =======
local animators = setmetatable({},{__mode = "k"})
local FPS = 60
local secsPerFrame = 1/FPS
local blankPoses = true

local priorityOrder = {
    [Enum.AnimationPriority.Core] = 1,
    [Enum.AnimationPriority.Idle] = 2,
    [Enum.AnimationPriority.Movement] = 3,
    [Enum.AnimationPriority.Action] = 4,
    [Enum.AnimationPriority.Action2] = 5,
    [Enum.AnimationPriority.Action3] = 6,
    [Enum.AnimationPriority.Action4] = 7,
}

local ArtificialHB = Instance.new("BindableEvent")
ArtificialHB.Name = "Heartbeat"

local tf = 0
local frame = 1/FPS
local maxFrameFix = 10
local allowframeloss = false
local tossremainder = false
local doquick = false

game:GetService("RunService").Heartbeat:Connect(function(s)
    tf = tf + s
    if tf >= frame then
        local maxFrames = math.min(maxFrameFix, math.floor(tf / frame))
        if allowframeloss then
            ArtificialHB:Fire()
        else
            for i = 1, maxFrames do
                ArtificialHB:Fire()
            end
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * maxFrames
        end
    end
end)

local function swait(num)
    if not num or num == 0 then
        ArtificialHB.Event:Wait()
    else
        for _ = 1, num do
            ArtificialHB.Event:Wait()
        end
    end
end

local function cfSort(t1,t2)
    if t1[3] == t2[3] then
        return t1[4] < t2[4]
    else
        return t1[3] < t2[3]
    end
end

local function shallowClone(tbl)
    local out = {}
    for k,v in pairs(tbl) do out[k] = v end
    return out
end

local function processAnimators()
    local toProcess = {}
    for animator,_ in pairs(animators) do
        table.insert(toProcess, animator)
    end

    local motorCFTable = {}

    for _, animator in ipairs(toProcess) do
        local motors = animator.Motors or {}
        local tracksClone = shallowClone(animator.Tracks or {})

        for _, track in pairs(tracksClone) do
            local weight = track.Weight or 0
            if weight == 0 then
                track.LastStepTime = track.StepTime or 0
                continue
            end

            track.StepTime = (track.StepTime or 0) + (secsPerFrame * (track.Speed or 1))

            -- ØªØ­Ù‚Ù‚ Ù…Ù† keyframes
            for _, keyframe in pairs(track.Keyframes or {}) do
                if keyframe.Time > (track.LastStepTime or 0) and keyframe.Time <= (track.StepTime or 0) then
                    if track.KeyframeReached and track.KeyframeReached.Fire then
                        track.KeyframeReached:Fire(keyframe.Name)
                    end
                end
            end

            if track.StepTime > track.Length then
                if track.Loop then
                    track.LastStepTime = 0
                    track.StepTime = track.StepTime % track.Length
                    if track.KeyframeReached and track.Keyframes and track.Keyframes[1] then
                        track.KeyframeReached:Fire(track.Keyframes[1].Name)
                    end
                elseif not track.StopFlag then
                    if track.Stop then track:Stop(0.3) end
                end
            end

            local gotMotors = {}

            for motorName, poses in pairs(track.Poses or {}) do
                local workPose = poses[1]
                local workPoseIndex = 1
                for i = 2, #poses do
                    local pose = poses[i]
                    if (track.StepTime or 0) >= pose[1] then
                        workPose = pose
                        workPoseIndex = i
                    else
                        break
                    end
                end

                local poseTime, poseInst = workPose[1], workPose[2]

                local motorTable = motors[motorName]
                if not motorTable then
                    warn("Motor not found for:", motorName)
                    continue
                end

                local originalmotor = motorTable -- has fields {m = motor6d, c = CFrame}
                local motor6d = originalmotor.m
                if not motor6d then
                    continue
                end

                local poseCF = poseInst.CFrame or CFrame.new()
                local motorCFs = motorCFTable[originalmotor]
                if not motorCFs then
                    motorCFs = {}
                    motorCFTable[originalmotor] = motorCFs
                end

                local lerpedCF
                local nextPose = poses[workPoseIndex+1]
                if not nextPose then
                    lerpedCF = poseCF
                else
                    local delta = 0
                    if nextPose[1] and poseTime and nextPose[1] ~= poseTime then
                        delta = ((track.StepTime or 0) - poseTime) / (nextPose[1] - poseTime)
                    end
                    lerpedCF = poseCF:Lerp(nextPose[2].CFrame, math.clamp(delta, 0, 1))
                end

                table.insert(motorCFs, {weight, lerpedCF, priorityOrder[track.Priority] or 1, track.PlayTime or 0})
                gotMotors[motor6d] = true
            end

            if blankPoses then
                -- Ù„ÙƒÙ„ Ù…Ø­Ø±Ùƒ ÙÙŠ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ØŒ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙØ­Ø¯Ù‘Ø¯ ÙˆØ¶Ø¹ÙŠØ© Ù„Ù‡ Ù†Ø¶Ø¹ Identity
                for _, motorTable in pairs(motors) do
                    local m6 = motorTable.m
                    if gotMotors[m6] then continue end
                    local motorCFs = motorCFTable[motorTable]
                    if not motorCFs then
                        motorCFs = {}
                        motorCFTable[motorTable] = motorCFs
                    end
                    table.insert(motorCFs, {weight or 1, CFrame.identity, priorityOrder[track.Priority] or 1, track.PlayTime or 0})
                end
            end

            track.LastStepTime = track.StepTime
        end
    end

    for motorTable, cframes in pairs(motorCFTable) do
        table.sort(cframes, cfSort)
        local c00 = motorTable.c -- original C0
        local motor6d = motorTable.m
        if not motor6d then continue end

        for _, cframe in ipairs(cframes) do
            local speed = math.clamp(cframe[1], 0, 1)
            if doquick then speed = 1 end
            -- Lerping C0 towards target
            motor6d.C0 = motor6d.C0:Lerp(c00 * cframe[2], speed)
        end
    end
    doquick = false
end

ArtificialHB.Event:Connect(processAnimators)

-- ======= ÙƒØ§Ø¦Ù†Ø§Øª Classes (Signal, Track, Animator) - Ù…ÙØ¨Ø³Ø· ÙˆÙ…ØªÙƒØ§Ù…Ù„ =======
local classes = {}

-- Signal
classes.Signal = (function()
    local mt = {}
    mt.__index = {
        Connect = function(self, func)
            local con = {Signal = self, Func = func}
            table.insert(self.Connections, con)
            local disconnected = false
            return {
                Disconnect = function()
                    if disconnected then return end
                    disconnected = true
                    for i, v in ipairs(self.Connections) do
                        if v == con then table.remove(self.Connections, i); break end
                    end
                end
            }
        end,
        Fire = function(self, ...)
            for _, v in ipairs(self.Connections) do
                task.spawn(v.Func, ...)
            end
        end
    }
    local function new()
        return setmetatable({Connections = {}}, mt)
    end
    return {new = new}
end)()

-- Track
classes.Track = (function()
    local funcs = {}
    local mt = {__index = funcs}

    local function initPoses(self)
        self.Poses = {}
        self.Keyframes = {}
        local seq = self.KeyframeSequence
        for _, v in pairs(seq:GetChildren()) do
            local keyTime = v.Time
            for _, pose in pairs(v:GetDescendants()) do
                if pose:IsA("Pose") and pose.Weight > 0 then
                    self.Poses[pose.Name] = self.Poses[pose.Name] or {}
                    table.insert(self.Poses[pose.Name], {keyTime, pose})
                end
            end
            if keyTime > self.Length then
                self.Length = keyTime
            end
            table.insert(self.Keyframes, v)
        end
        for _, t in pairs(self.Poses) do
            table.sort(t, function(a,b) return a[1] < b[1] end)
        end
    end

    local function fadeWeight(self, target, secs)
        local startTime = tick()
        local endTime = startTime + secs
        local startWeight = self.Weight
        self.LastFade = startTime
        task.spawn(function()
            while true do
                if self.LastFade ~= startTime then return end
                local curTime = tick()
                if curTime >= endTime then break end
                local frac = (curTime - startTime) / (endTime - startTime)
                self.Weight = startWeight + (target - startWeight) * frac
                task.wait()
            end
            self.Weight = target
            if target == 0 then
                local foundInd = table.find(self.Animator.Tracks, self)
                if foundInd then table.remove(self.Animator.Tracks, foundInd) end
            end
        end)
    end

    function funcs:Play(fadeTime, weight, speed)
        self.Speed = speed or 1
        self.PlayTime = tick()
        if not self.Loop or self.Weight == 0 then
            self.LastStepTime = 0
            self.StepTime = 0
        end
        self.StopFlag = false
        self.IsPlaying = true
        fadeWeight(self, weight or 1, fadeTime or 0.1)
        doquick = true
        if not table.find(self.Animator.Tracks, self) then
            table.insert(self.Animator.Tracks, self)
        end
    end

    function funcs:Stop(fadeTime)
        self.StopFlag = true
        self.IsPlaying = false
        fadeWeight(self, 0, fadeTime or 0.1)
        if self.Stopped and self.Stopped.Fire then
            self.Stopped:Fire()
        end
    end

    local function new(animator, keyframeSeq)
        local self = setmetatable({
            KeyframeSequence = keyframeSeq,
            Speed = 1,
            Weight = 0,
            LastStepTime = 0,
            StepTime = 0,
            Length = 0,
            Loop = keyframeSeq and keyframeSeq.Loop or false,
            LastFade = 0,
            PlayTime = 0,
            Priority = keyframeSeq and keyframeSeq.Priority or Enum.AnimationPriority.Idle,
            KeyframeReached = classes.Signal.new(),
            Animator = animator,
            IsPlaying = false,
            Stopped = classes.Signal.new()
        }, mt)
        initPoses(self)
        return self
    end

    return {new = new}
end)()

-- Animator
classes.Animator = (function()
    local funcs = {}
    local mt = {__index = funcs}

    function funcs:InitMotors()
        self.Motors = {}
        for _, v in pairs(self.Model:GetDescendants()) do
            if v:IsA("Motor6D") then
                -- Ø§Ù„Ø®Ø±ÙŠØ·Ø© ØªÙƒÙˆÙ† Ø¨Ø§Ø³Ù… Part1 Ù„ØªÙˆØ§ÙÙ‚ Ø§Ù„Ù€ poses ÙÙŠ KeyframeSequence
                local key = v.Part1 and v.Part1.Name or v.Name
                self.Motors[key] = {m = v, c = v.C0}
            elseif v:IsA("Bone") then
                self.Motors[v.Name] = {m = v, c = CFrame.new()}
            end
        end
    end

    function funcs:LoadAnimation(keyframeSeq)
        return classes.Track.new(self, keyframeSeq)
    end

    local function new(model)
        local self = setmetatable({
            Tracks = {},
            Motors = {},
            Model = model
        }, mt)
        self:InitMotors()
        animators[self] = true
        return self
    end

    return {new = new}
end)()

local function createAnimator(model)
    return classes.Animator.new(model)
end

-- ======= Ø§Ù„Ø±Ø¨Ø· Ù…Ø¹ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø§Ù„Ù…Ø­Ù„ÙŠØ© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­ÙˆÙŠÙ„ =======
-- Ø¹Ù†Ø¯Ù…Ø§ ØªØ´ØºÙ‘Ù„ spawnMonkyAsCharacter() Ø³ÙŠØ¹ÙŠØ¯ mobChar Ùˆ humanoid
-- Ø³Ù†Ø¨Ù‚ÙŠ ÙƒÙˆØ¯ Ø§Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù† Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­ÙˆÙŠÙ„

-- ======= Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© (GUI) Ø§Ù„Ù…ØµØ­Ø­Ø© =======
-- Ù†Ù†Ø´Ø¦ GUI Ø¨Ø³ÙŠØ· Ù„Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª
local function createControllerGui()
    if not localPlayer then return end
    local playerGui = localPlayer:WaitForChild("PlayerGui")

    -- Ø¥Ù† ÙˆÙØ¬Ø¯ Ø¨Ø§Ù„ÙØ¹Ù„ Ù†ØªØ®Ø·Ù‘Ù‰ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡
    if playerGui:FindFirstChild("ControllerGui") then
        return playerGui.ControllerGui
    end

    local ControllerGui = Instance.new("ScreenGui")
    ControllerGui.Name = "ControllerGui"
    ControllerGui.ResetOnSpawn = false
    ControllerGui.Parent = playerGui

    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "Frame"
    mainFrame.Parent = ControllerGui
    mainFrame.BackgroundColor3 = Color3.fromRGB(45,45,45)
    mainFrame.Position = UDim2.new(0.05,0,0.6,0)
    mainFrame.Size = UDim2.new(0,150,0,120)
    mainFrame.AnchorPoint = Vector2.new(0,0)

    local UICorner = Instance.new("UICorner", mainFrame)

    local Title = Instance.new("TextLabel")
    Title.Name = "Title"
    Title.Parent = mainFrame
    Title.BackgroundTransparency = 1
    Title.Position = UDim2.new(0,5,0,0)
    Title.Size = UDim2.new(1,-10,0,25)
    Title.Font = Enum.Font.SourceSansBold
    Title.Text = "Primadon"
    Title.TextColor3 = Color3.fromRGB(255,255,255)
    Title.TextSize = 14

    -- Ø£Ø²Ø±Ø§Ø±
    local function makeBtn(text, y, callback)
        local btn = Instance.new("TextButton")
        btn.Parent = mainFrame
        btn.Size = UDim2.new(1, -10, 0, 28)
        btn.Position = UDim2.new(0,5,0,y)
        btn.Text = text
        btn.Font = Enum.Font.SourceSans
        btn.TextSize = 14
        btn.BackgroundColor3 = Color3.fromRGB(0,135,203)
        local c = Instance.new("UICorner", btn)
        if callback then
            btn.MouseButton1Click:Connect(callback)
        end
        return btn
    end

    -- Ø£Ø²Ø±Ø§Ø± ØªØ§Ø¨Ø¹Ø© Ù„Ù„ÙˆØ¸Ø§Ø¦Ù: Ø³Ù†Ø±Ø¨Ø·Ù‡Ø§ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ø¨Ø¹Ø¯ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù†/Ø§Ù„Ø´Ø®ØµÙŠØ©
    local btnExecute = makeBtn("Execute (M)", 30, function() end)
    local btnAwaken = makeBtn("Awaken (J)", 64, function() end)

    -- ÙˆØ¸ÙŠÙØ© Ù„Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„ØªÙˆØµÙŠÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§
    return {
        Gui = ControllerGui,
        Frame = mainFrame,
        ExecuteBtn = btnExecute,
        AwakenBtn = btnAwaken
    }
end

local controller = createControllerGui()

-- ======= Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ØµÙˆØ§Øª ÙˆØ§Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù† Ø§Ù„Ù…ØªØ­ÙƒÙ… Ø¨Ù‡ (Ø³ÙŠØ¹Ù…Ù„ Ø¨Ø¹Ø¯ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø´Ø®ØµÙŠØ©) =======
-- Ø³Ù†Ù†ØªØ¸Ø± Ø£Ù† ÙŠÙ‚ÙˆÙ… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ­ÙˆÙŠÙ„ (Ù…Ø«Ù„Ø§Ù‹ Ø¹Ø¨Ø± Ø§Ù„Ø£Ù…Ø± !primadon)
-- Ø£Ùˆ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ spawnMonkyAsCharacter() Ù…Ø¨Ø§Ø´Ø±Ø© Ù„ØªØ¬Ø±Ø¨Ø© Ù…Ø­Ù„ÙŠØ©

-- ØªØ¹Ø±ÙŠÙ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ø³ØªØ®Ø¯Ø§Ù…ÙŠØ© Ø¨Ø­ÙŠØ« ØªÙÙ‡ÙŠØ£ Ø¨Ø¹Ø¯ spawn
local runtime = {
    MobChar = nil,
    Humanoid = nil,
    Animator = nil,
    CurrentTrack = nil,
    Cooldowns = {},
    CooldownTimes = {
        [Enum.KeyCode.M] = 4,
        [Enum.KeyCode.C] = 2,
        [Enum.KeyCode.X] = 2,
        [Enum.KeyCode.J] = 1
    },
    Sounds = {},
    AnimsFolder = nil
}

local function setupRuntimeAfterSpawn(mobChar, humanoid)
    if not mobChar or not humanoid then return end
    runtime.MobChar = mobChar
    runtime.Humanoid = humanoid

    -- Ø§Ù†ØªØ¸Ø± Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø£Ù†ÙŠÙ…ÙŠØ´Ù† ÙˆØ§Ù„ØµÙˆØª Ø¥Ù† ÙˆØ¬Ø¯
    local an = mobChar:FindFirstChild("Anims")
    local so = mobChar:FindFirstChild("Sounds")
    runtime.AnimsFolder = an
    runtime.Sounds = so or {}

    -- Ø¥Ù†Ø´Ø§Ø¡ animator Ù…Ø­Ù„ÙŠ
    runtime.Animator = createAnimator(mobChar)

    -- helper Ù„ØªØ´ØºÙŠÙ„ KeyframeSequence
    local function playKeyframeSequence(seq, looped)
        if not seq then return end
        if runtime.CurrentTrack then
            runtime.CurrentTrack:Stop(0.2)
        end
        local track = runtime.Animator:LoadAnimation(seq)
        track.Looped = looped or false
        track:Play(0.2, 1, 1)
        runtime.CurrentTrack = track
        return track
    end

    -- Ø®Ø·ÙˆØ§Øª Ø§Ù„ØµÙˆØª Ø§Ù„Ù…Ø´ÙŠØ©
    local walking = false
    local monkyStep = runtime.Sounds:FindFirstChild("MonkyStep")
    local function playStepLoop()
        if not monkyStep then return end
        if walking then return end
        walking = true
        task.spawn(function()
            while walking do
                monkyStep.Volume = 5.3
                monkyStep:Play()
                task.wait(1.4)
                monkyStep:Stop()
                task.wait(0.2)
            end
        end)
    end
    local function stopStepLoop()
        walking = false
        if monkyStep and monkyStep.IsPlaying then monkyStep:Stop() end
    end

    -- ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ© ØªØ¨Ø¹Ø§Ù‹ Ù„Ù„Ø­Ø§Ù„Ø©
    local function updateAnimation()
        local cur = runtime.CurrentTrack
        if cur and (cur.Name == "Execute" or cur.Name == "Awaken" or cur.Name == "Grab" or cur.Name == "Swipe") then
            return
        end
        if runtime.Humanoid.MoveDirection and runtime.Humanoid.MoveDirection.Magnitude > 0 then
            if runtime.AnimsFolder then
                local walkAnim = runtime.AnimsFolder:FindFirstChild("Walk")
                if walkAnim then playKeyframeSequence(walkAnim, true) end
            end
            playStepLoop()
        elseif runtime.Humanoid:GetState() == Enum.HumanoidStateType.Jumping or runtime.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            if runtime.AnimsFolder then playKeyframeSequence(runtime.AnimsFolder:FindFirstChild("Jump"), false) end
            stopStepLoop()
        else
            if runtime.AnimsFolder then playKeyframeSequence(runtime.AnimsFolder:FindFirstChild("Idle"), true) end
            stopStepLoop()
        end
    end

    runtime.Humanoid.Running:Connect(updateAnimation)
    runtime.Humanoid.StateChanged:Connect(updateAnimation)
    updateAnimation()

    -- ÙˆØ¸Ø§Ø¦Ù ØªØ´ØºÙŠÙ„ Ù…Ø³Ù…ÙˆØ­Ø§Øª Ù…Ø¹ ÙƒÙˆÙ„Ø¯Ø§ÙˆÙ†
    local function playWithCooldown(animKF, sound, name, key)
        if runtime.Cooldowns[key] then return end
        if not animKF then return end

        runtime.Cooldowns[key] = true
        if runtime.CurrentTrack then
            runtime.CurrentTrack:Stop(0.2)
            runtime.CurrentTrack = nil
        end

        local track = runtime.Animator:LoadAnimation(animKF)
        track.Name = name
        track.Looped = false
        track:Play(0.1, 1, 1)
        runtime.CurrentTrack = track

        if sound then
            sound.Volume = 9
            sound:Play()
        end

        track.Stopped:Connect(function()
            runtime.CurrentTrack = nil
            updateAnimation()
            local duration = runtime.CooldownTimes[key] or 1
            task.delay(duration, function() runtime.Cooldowns[key] = false end)
        end)
    end

    -- Ø§Ø®ØªØµØ§Ø±Ø§Øª
    local monkyScream = runtime.Sounds:FindFirstChild("MonkyScream")
    local executeSound = runtime.Sounds:FindFirstChild("Swing1")
    local grabSound = runtime.Sounds:FindFirstChild("Swing2")
    local swipeSound = executeSound

    local swipeKF = runtime.AnimsFolder and runtime.AnimsFolder:FindFirstChild("Swipe")
    local executeKF = runtime.AnimsFolder and runtime.AnimsFolder:FindFirstChild("Execute")
    local awakenKF = runtime.AnimsFolder and runtime.AnimsFolder:FindFirstChild("Awaken")
    local grabKF = runtime.AnimsFolder and runtime.AnimsFolder:FindFirstChild("Grab")

    local awekenUsed = false

    local function playExecute() playWithCooldown(executeKF, executeSound, "Execute", Enum.KeyCode.M) end
    local function playAwaken()
        if awekenUsed then return end
        awekenUsed = true
        playWithCooldown(awakenKF, monkyScream, "Awaken", Enum.KeyCode.J)
    end
    local function playGrab() playWithCooldown(grabKF, grabSound, "Grab", Enum.KeyCode.C) end
    local function playSwipe() playWithCooldown(swipeKF, swipeSound, "Swipe", Enum.KeyCode.X) end

    -- ÙˆØµÙ„ Ù…ÙØ§ØªÙŠØ­ Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯
    UIS.InputBegan:Connect(function(input, gpe)
        if gpe then return end
        if input.KeyCode == Enum.KeyCode.M then
            playExecute()
        elseif input.KeyCode == Enum.KeyCode.J then
            playAwaken()
        elseif input.KeyCode == Enum.KeyCode.C then
            playGrab()
        elseif input.KeyCode == Enum.KeyCode.X then
            playSwipe()
        end
    end)

    -- ÙˆØµÙ„ Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ù„Ùˆ ÙˆØ¬Ø¯Øª
    if controller and controller.ExecuteBtn then
        controller.ExecuteBtn.MouseButton1Click:Connect(playExecute)
    end
    if controller and controller.AwakenBtn then
        controller.AwakenBtn.MouseButton1Click:Connect(playAwaken)
    end
end

-- Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙÙ†Ø§Ø¯Ù‰ Ø§Ù„Ø£Ù…Ø± !primadon ÙÙŠ Ø§Ù„Ø´Ø§Øª Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø§Ù„ÙƒØŒ Ù†Ù†ÙÙ‘Ø° Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù…Ø­Ù„ÙŠÙ‹Ø§
-- Ø³Ù†Ø¹Ø¯Ù‘Ù„ processCommand Ù„ÙŠØ³ØªØ¯Ø¹ÙŠ spawnMonkyAsCharacter Ø¹Ù†Ø¯ Ù…Ø§Ù„Ùƒ Ø§Ù„Ø£Ù…Ø±
-- (Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹Ø±ÙŠÙ Ø¨Ø³ÙŠØ· Ù„ØªØ¹Ø²ÙŠØ² Ø§Ù„Ø±Ø¨Ø·)
do
    local oldProcessCommand = processCommand
    processCommand = function(player, message)
        oldProcessCommand(player, message)
        if not player then return end
        if message and message:lower() == "!primadon" and isOwner(player) and player == localPlayer then
            -- Ø­Ø¯Ø¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹ Ù…Ù†Ø¹ Ø§Ù„ØªÙØ¹ÙŠÙ„ Ø£ÙƒØ«Ø± Ù…Ù† Ù…Ø±Ø©
            if runtime.MobChar then
                notifyPlayer(localPlayer, "Primadon already active.")
                return
            end
            local mobChar, humanoid = spawnMonkyAsCharacter()
            if mobChar and humanoid then
                notifyPlayer(localPlayer, "ğŸ¦ Primadon spawned and attached!")
                setupRuntimeAfterSpawn(mobChar, humanoid)
            else
                notifyPlayer(localPlayer, "âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Primadon")
            end
        end
    end
end

-- Ø·Ø¨Ø§Ø¹Ø© Ø­Ø§Ù„Ø© ØªÙØ¹ÙŠÙ„ ÙÙŠ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
print("ğŸ¦ Primadon System (LocalScript) loaded.")
print("â­ Owner ID: " .. tostring(_G.ControllerID))

-- Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¥Ø­Ø¶Ø§Ø± Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
local function getInfo()
    return {
        OwnerID = _G.ControllerID,
        TotalPlayers = #Players:GetPlayers(),
        IsOwner = isOwner(localPlayer)
    }
end

-- ØªÙØ¹ÙŠØ¯ ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø±Ù…Ø¬ÙŠØ© Ø¨Ø³ÙŠØ·Ø© Ø¥Ù† Ø£Ø±Ø¯Øª Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ Ù…Ù† Ù…ÙƒØ§Ù† Ø¢Ø®Ø±
return {
    activate = function() print("Primadon system available (local).") end,
    isOwner = isOwner,
    getInfo = getInfo,
    spawnNow = function() local m,h = spawnMonkyAsCharacter(); if m and h then setupRuntimeAfterSpawn(m,h) end end,
}
