local _G = {
    ControllerID = 9822837105,
    CommandCooldown = {}
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")

local function isOwner(player)
    return player.UserId == _G.ControllerID
end

local function notifyPlayer(player, message)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Primadon System",
            Text = message,
            Duration = 5
        })
    end)
end

local function checkCooldown(player)
    if _G.CommandCooldown[player.UserId] and os.time() - _G.CommandCooldown[player.UserId] < 2 then
        notifyPlayer(player, "‚è≥ Wait 2 seconds between commands")
        return false
    end
    _G.CommandCooldown[player.UserId] = os.time()
    return true
end

-- ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ£ŸÜŸäŸÖŸäÿ¥ŸÜ ÿßŸÑŸÖÿ™ŸÇÿØŸÖ
local animators = setmetatable({},{__mode = "k"})
local FPS = 60
local secsPerFrame = 1/FPS
local blankPoses = true

local priorityOrder = {
	[Enum.AnimationPriority.Core] = 1,
	[Enum.AnimationPriority.Idle] = 2,
	[Enum.AnimationPriority.Movement] = 3,
	[Enum.AnimationPriority.Action] = 4,
	[Enum.AnimationPriority.Action2] = 5,
	[Enum.AnimationPriority.Action3] = 6,
	[Enum.AnimationPriority.Action4] = 7,
}

-- Artificial Heartbeat --
local ArtificialHB = Instance.new("BindableEvent")
ArtificialHB.Name = "Heartbeat"

local tf = 0
local allowframeloss = false
local tossremainder = false
local frame = 1/FPS
local maxFrameFix = 10
ArtificialHB:Fire()
local doquick = false

game:GetService("RunService").Heartbeat:Connect(function(s, p)
	tf += s
	if tf >= frame then
		local maxFrames = math.min(maxFrameFix, math.floor(tf / frame))
		if allowframeloss then
			ArtificialHB:Fire()
		else
			for i = 1, maxFrames do
				ArtificialHB:Fire()
			end
		end
		if tossremainder then
			tf = 0
		else
			tf -= frame * maxFrames
		end
	end
end)

local function cfSort(t1,t2)
	if t1[3] == t2[3] then
		return t1[4] < t2[4]
	else
		return t1[3] < t2[3]
	end
end

local function processAnimators()
	local toProcess = {}
	for animator in animators do table.insert(toProcess,animator) end

	local motorCFTable = {}

	for _,animator in ipairs(toProcess) do
		local motors = animator.Motors
		local tracksClone = table.clone(animator.Tracks)

		for _,track in pairs(tracksClone) do
			local weight = track.Weight
			if weight == 0 then continue end
			track.StepTime += secsPerFrame*track.Speed

			for _,keyframe in pairs(track.Keyframes) do
				if keyframe.Time > track.LastStepTime and keyframe.Time <= track.StepTime then
					track.KeyframeReached:Fire(keyframe.Name)
				end
			end

			if track.StepTime > track.Length then
				if track.Loop then
					track.LastStepTime = 0
					track.StepTime = track.StepTime % track.Length
					track.KeyframeReached:Fire(track.Keyframes[1].Name)
				elseif not track.StopFlag then
					track:Stop(0.3)
				end
			end

			local gotMotors = {}
			for motorName,poses in pairs(track.Poses) do
				local workPose = poses[1]
				local workPoseIndex = 1

				for i = 2,#poses do
					local pose = poses[i]
					if track.StepTime >= pose[1] then
						workPose = pose
						workPoseIndex = i
					else
						break
					end
				end

				local poseTime,poseInst = workPose[1],workPose[2]

				local motor = motors[motorName]
                if not motor then
                    warn("Motor not found for:", motorName)
                    continue
                end

                local c00 = motor.c
                local originalmotor = motor
                motor = motor.m
                if not motor then continue end

                local poseCF = poseInst.CFrame
                local motorCFs = motorCFTable[originalmotor]
                if not motorCFs then
                    motorCFs = {}
                    motorCFTable[originalmotor] = motorCFs
                end

				local lerpedCF
				local nextPose = poses[workPoseIndex+1]
				if not nextPose then
					lerpedCF = poseCF
				else
					local delta = (track.StepTime - poseTime)/(nextPose[1] - poseTime)
					lerpedCF = poseCF:Lerp(nextPose[2].CFrame,delta)
				end

				table.insert(motorCFs,{weight,lerpedCF,priorityOrder[track.Priority],track.PlayTime})
				gotMotors[motor] = true
			end

			if blankPoses then
				for _,motor in motors do
					if gotMotors[motor.m] then continue end
					local motorCFs = motorCFTable[motor]
					if not motorCFs then
						motorCFs = {}
						motorCFTable[motor] = motorCFs
					end
					table.insert(motorCFs,{weight,CFrame.identity,priorityOrder[track.Priority],track.PlayTime})
				end
			end

			track.LastStepTime = track.StepTime
		end
	end

	for motor,cframes in pairs(motorCFTable) do
		table.sort(cframes,cfSort)
		local c00 = motor.c
		local motor6d = motor.m

		for _,cframe in ipairs(cframes) do
			local speed = math.clamp(cframe[1],0,1)
			if doquick then speed = 1 end
			motor6d.C0 = motor6d.C0:Lerp(c00 * cframe[2],speed)
		end
	end
	doquick = false
end

ArtificialHB.Event:Connect(processAnimators)

-- Classes
local classes = {}

classes.Signal = (function()
	local funcs = {}
	local disconnect = function(con)
		local pos = table.find(con.Signal.Connections,con)
		if pos then table.remove(con.Signal.Connections,pos) end
	end
	funcs.Connect = function(self,func)
		local con = {Signal=self,Func=func,Disconnect=disconnect}
		self.Connections[#self.Connections+1] = con
		return con
	end
	funcs.Fire = function(self,...)
		for _,v in next,self.Connections do
			task.spawn(v.Func,...)
		end
	end
	local mt = {__index = funcs}
	local function new()
		local self = {Connections={}}
		return setmetatable(self,mt)
	end
	return {new = new}
end)()

classes.Track = (function()
	local funcs = {}
	local mt = {__index = funcs}

	local function initPoses(self)
		local poses = self.Poses
		for _,v in pairs(self.KeyframeSequence:GetChildren()) do
			local keyTime = v.Time
			for _,pose in pairs(v:GetDescendants()) do
				if pose:IsA("Pose") and pose.Weight > 0 then
					local poseTable = poses[pose.Name]
					if not poseTable then
						poseTable = {}
						poses[pose.Name] = poseTable
					end
					table.insert(poseTable,{keyTime,pose})
				end
			end
			if keyTime > self.Length then
				self.Length = keyTime
			end
			table.insert(self.Keyframes,v)
		end
		for _,v in pairs(poses) do
			table.sort(v,function(a,b) return a[1] < b[1] end)
		end
	end

	local function fadeWeight(self,target,secs)
		local startTime = tick()
		local endTime = startTime+secs
		local startWeight = self.Weight
		self.LastFade = startTime
		task.spawn(function()
			while true do
				if self.LastFade ~= startTime then return end
				local curTime = tick()
				if curTime >= endTime then break end
				local frac = (curTime - startTime)/(endTime - startTime)
				self.Weight = startWeight + (target - startWeight)*frac
				task.wait()
			end
			self.Weight = target
			if target == 0 then
				local foundInd = table.find(self.Animator.Tracks,self)
				if foundInd then
					table.remove(self.Animator.Tracks,foundInd)
				end
			end
		end)
	end

	funcs.Play = function(self,fadeTime,weight,speed)
		self.Speed = speed or 1
		self.PlayTime = tick()
		if not self.Loop or self.Weight == 0 then
			self.LastStepTime = 0
			self.StepTime = 0
		end
		self.StopFlag = false
		self.IsPlaying = true
		fadeWeight(self,weight or 1,fadeTime or 0.1)
		doquick = true
		if not table.find(self.Animator.Tracks,self) then
			table.insert(self.Animator.Tracks,self)
		end
	end

	funcs.Stop = function(self,fadeTime)
		self.StopFlag = true
		self.IsPlaying = false
		fadeWeight(self,0,fadeTime or 0.1)
		self.Stopped:Fire()
	end

	local function new(animator,keyframeSeq)
		local self = setmetatable({
			Poses = {},
			Keyframes = {},
			Speed = 1,
			Weight = 0,
			LastStepTime = 0,
			StepTime = 0,
			Length = 0,
			Loop = keyframeSeq.Loop,
			LastFade = 0,
			PlayTime = 0,
			Priority = keyframeSeq.Priority,
			KeyframeReached = classes.Signal.new(),
			KeyframeSequence = keyframeSeq,
			Animator = animator,
			IsPlaying = false,
			Stopped = classes.Signal.new()
		},mt)
		initPoses(self)
		return self
	end

	return {new = new}
end)()

classes.Animator = (function()
	local funcs = {}
	local mt = {__index = funcs}

	funcs.InitMotors = function(self)
		for _,v in pairs(self.Model:GetDescendants()) do
			if v:IsA("Motor6D") then
				self.Motors[v.Part1.Name] = {m=v,c=v.C0}
			elseif v:IsA("Bone") then
				self.Motors[v.Name] = {m=v,c=CFrame.new()}
			end
		end
	end

	funcs.LoadAnimation = function(self,keyframeSeq)
		local newTrack = classes.Track.new(self,keyframeSeq)
		return newTrack
	end

	local function new(model)
		local self = setmetatable({
			Tracks = {},
			Motors = {},
			Model = model
		},mt)
		self:InitMotors()
		animators[self] = true
		return self
	end

	return {new = new}
end)()

local function createAnimator(model)
	return classes.Animator.new(model)
end

local function setupPrimadonAbilities(mobChar)
    local animsFolder = mobChar:WaitForChild("Anims")
    local soundsFolder = mobChar:WaitForChild("Sounds")

    local animator = createAnimator(mobChar)
    local currentTrack
    local awekenUsed = false

    local monkyScream = soundsFolder:FindFirstChild("MonkyScream")
    local monkyStep = soundsFolder:FindFirstChild("MonkyStep")
    local executeSound = soundsFolder:FindFirstChild("Swing1")
    local grabSound = soundsFolder:FindFirstChild("Swing2")
    local swipeKF = animsFolder:FindFirstChild("Swipe")
    local swipeSound = executeSound

    local cooldowns = {}
    local cooldownTimes = {
        [Enum.KeyCode.M] = 4,
        [Enum.KeyCode.C] = 2,
        [Enum.KeyCode.X] = 2,
        [Enum.KeyCode.J] = 1
    }

    local function playKeyframeSequence(seq, looped)
        if not seq then return end
        if currentTrack then
            currentTrack:Stop(0.2)
        end
        local track = animator:LoadAnimation(seq)
        track.Looped = looped or false
        track:Play(0.2, 1, 1)
        currentTrack = track
        return track
    end

    local walking = false
    local function playStepLoop()
        if not monkyStep then return end
        if walking then return end
        walking = true
        task.spawn(function()
            while walking do
                monkyStep.Volume = 5.3
                monkyStep:Play()
                task.wait(1.4)
                monkyStep:Stop()
                task.wait(0.2)
            end
        end)
    end

    local function stopStepLoop()
        walking = false
        if monkyStep and monkyStep.IsPlaying then
            monkyStep:Stop()
        end
    end

    local function updateAnimation()
        if currentTrack and (currentTrack.Name == "Execute" or currentTrack.Name == "Awaken" or currentTrack.Name == "Grab" or currentTrack.Name == "Swipe") then
            return
        end
        local humanoid = mobChar:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.MoveDirection.Magnitude > 0 then
            local walkAnim = animsFolder:FindFirstChild("Walk")
            if walkAnim then
                playKeyframeSequence(walkAnim, true)
            end
            playStepLoop()
        elseif humanoid and (humanoid:GetState() == Enum.HumanoidStateType.Jumping or humanoid:GetState() == Enum.HumanoidStateType.Freefall) then
            playKeyframeSequence(animsFolder:FindFirstChild("Jump"), false)
            stopStepLoop()
        else
            playKeyframeSequence(animsFolder:FindFirstChild("Idle"), true)
            stopStepLoop()
        end
    end

    local humanoid = mobChar:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Running:Connect(updateAnimation)
        humanoid.StateChanged:Connect(updateAnimation)
    end
    updateAnimation()

    local function playWithCooldown(animKF, sound, name, key)
        if cooldowns[key] then return end
        if not animKF then return end

        cooldowns[key] = true
        if currentTrack then
            currentTrack:Stop(0.2)
            currentTrack = nil
        end

        local track = animator:LoadAnimation(animKF)
        track.Name = name
        track.Looped = false
        track:Play(0.1, 1, 1)
        currentTrack = track

        if sound then
            sound.Volume = 9
            sound:Play()
        end

        track.Stopped:Connect(function()
            currentTrack = nil
            updateAnimation()
            local duration = cooldownTimes[key] or 1
            task.delay(duration, function()
                cooldowns[key] = false
            end)
        end)
    end

    local function playExecute() playWithCooldown(animsFolder:FindFirstChild("Execute"), executeSound, "Execute", Enum.KeyCode.M) end
    local function playAwaken()
        if awekenUsed then return end
        awekenUsed = true
        playWithCooldown(animsFolder:FindFirstChild("Awaken"), monkyScream, "Awaken", Enum.KeyCode.J)
    end
    local function playGrab() playWithCooldown(animsFolder:FindFirstChild("Grab"), grabSound, "Grab", Enum.KeyCode.C) end
    local function playSwipe() playWithCooldown(swipeKF, swipeSound, "Swipe", Enum.KeyCode.X) end

    UIS.InputBegan:Connect(function(input, gpe)
        if gpe then return end
        local localPlayer = Players.LocalPlayer
        if localPlayer.Character == mobChar then
            if input.KeyCode == Enum.KeyCode.M then
                playExecute()
                notifyPlayer(localPlayer, "üí• Execute activated!")
            elseif input.KeyCode == Enum.KeyCode.J then
                playAwaken()
                notifyPlayer(localPlayer, "üî• Awaken activated!")
            elseif input.KeyCode == Enum.KeyCode.C then
                playGrab()
                notifyPlayer(localPlayer, "üîÑ Grab activated!")
            elseif input.KeyCode == Enum.KeyCode.X then
                playSwipe()
                notifyPlayer(localPlayer, "‚ö° Swipe activated!")
            end
        end
    end)
end

local function createControlGUI()
    local player = Players.LocalPlayer
    local gui = Instance.new("ScreenGui")
    gui.Name = "PrimadonControlGUI"
    gui.Parent = player:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 200)
    frame.Position = UDim2.new(0, 10, 0, 10)
    frame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    frame.BorderSizePixel = 0
    frame.Parent = gui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, 0, 0, 30)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    title.Text = "ü¶ç Primadon Controls"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 14
    title.Parent = frame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = title
    
    local controls = {
        {"M - Execute", Color3.fromRGB(255, 50, 50)},
        {"J - Awaken", Color3.fromRGB(255, 150, 50)},
        {"C - Grab", Color3.fromRGB(50, 150, 255)},
        {"X - Swipe", Color3.fromRGB(150, 255, 50)},
        {"Walk - Auto Animation", Color3.fromRGB(255, 255, 255)},
        {"Jump - Auto Animation", Color3.fromRGB(255, 255, 255)}
    }
    
    for i, control in ipairs(controls) do
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, -10, 0, 25)
        label.Position = UDim2.new(0, 5, 0, 30 + (i * 25))
        label.BackgroundTransparency = 1
        label.Text = control[1]
        label.TextColor3 = control[2]
        label.Font = Enum.Font.SourceSans
        label.TextSize = 12
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = frame
    end
    
    local dragInput
    local dragStart
    local startPos
    
    local function update(input)
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(0, startPos.X.Offset + delta.X, 0, startPos.Y.Offset + delta.Y)
    end
    
    title.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragInput = nil
                end
            end)
        end
    end)
    
    title.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)
    
    UIS.InputChanged:Connect(function(input)
        if input == dragInput then
            update(input)
        end
    end)
    
    return gui
end

local function transformToPrimadon(player)
    if not player.Character then return end
    
    local success, result = pcall(function()
        local model = game:GetObjects("rbxassetid://17523790773")[1]
        local monkyContainer = model:FindFirstChild("MonkyContainer")
        local mobChar = monkyContainer and monkyContainer:FindFirstChild("Main") and monkyContainer.Main:FindFirstChild("Monky")
        if not mobChar then
            warn("Monky character not found")
            return
        end

        mobChar.Parent = workspace

        local humanoid = mobChar:WaitForChild("Humanoid")
        local hrp = mobChar:WaitForChild("HumanoidRootPart")

        hrp.CFrame = player.Character.HumanoidRootPart.CFrame + Vector3.new(0,40,0)

        humanoid.MaxHealth = 999999999
        humanoid.Health = 999999999
        humanoid.WalkSpeed = 32
        humanoid.JumpPower = 300
        humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None

        local oldChar = player.Character
        player.Character = mobChar

        local cam = workspace.CurrentCamera
        cam.CameraSubject = humanoid
        cam.CFrame = hrp.CFrame

        if oldChar and oldChar ~= mobChar then
            oldChar:Destroy()
        end

        if monkyContainer then
            local mainModule = monkyContainer:FindFirstChild("MainModule")
            if mainModule then
                mainModule:Destroy()
            end
        end
        
        setupPrimadonAbilities(mobChar)
        
        if player == Players.LocalPlayer then
            createControlGUI()
        end
        
        return mobChar
    end)
    
    if success then
        notifyPlayer(player, "ü¶ç Primadon transformation successful!")
        return result
    else
        notifyPlayer(player, "‚ùå Transformation failed: " .. tostring(result))
        return nil
    end
end

local function processCommand(player, message)
    local command = message:lower()
    
    if not checkCooldown(player) then return end
    
    if isOwner(player) then
        if command == "!p" then
            transformToPrimadon(player)
        elseif command == "!primadon" then
            transformToPrimadon(player)
        elseif command == "!help" then
            notifyPlayer(player, "ü¶ç Commands: !p, !primadon")
        end
    else
        if command == "!p" or command == "!primadon" then
            notifyPlayer(player, "‚ùå Only the owner can use this command!")
        end
    end
end

local function monitorPlayer(player)
    player.Chatted:Connect(function(message)
        if message:lower():sub(1, 1) == "!" then
            processCommand(player, message)
        end
    end)
end

local function startMonitoring()
    for _, player in ipairs(Players:GetPlayers()) do
        monitorPlayer(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    monitorPlayer(player)
    if isOwner(player) then
        notifyPlayer(player, "üéÆ You are the owner! Use !p to transform into Primadon")
    end
end)

print("ü¶ç Primadon System activated!")
print("‚≠ê Owner ID: " .. _G.ControllerID)
startMonitoring()

local localPlayer = Players.LocalPlayer
if localPlayer and isOwner(localPlayer) then
    notifyPlayer(localPlayer, "ü¶ç Primadon system ready! Use !p to transform")
end

return {
    isOwner = isOwner,
    transformToPrimadon = transformToPrimadon,
    getInfo = function()
        return {
            OwnerID = _G.ControllerID,
            IsOwner = isOwner(Players.LocalPlayer)
        }
    end
}
