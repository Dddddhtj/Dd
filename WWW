local _G = {
    ControllerID = 9822837105,
    CommandCooldown = {}
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local function isOwner(player)
    return player.UserId == _G.ControllerID
end

local function notifyPlayer(player, message)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Train System",
            Text = message,
            Icon = "rbxassetid://0",
            Duration = 5
        })
    end)
end

local function checkCooldown(player)
    if _G.CommandCooldown[player.UserId] and os.time() - _G.CommandCooldown[player.UserId] < 2 then
        notifyPlayer(player, "â³ Wait 2 seconds between commands")
        return false
    end
    _G.CommandCooldown[player.UserId] = os.time()
    return true
end

-- Train Transformation System
local trainParts = {}
local trainSounds = {}
local isTrainMode = false
local mergeConnections = {}

local function SFX(id, parent)
    local s = Instance.new("Sound", parent)
    s.SoundId = "rbxassetid://" .. id
    s.Volume = 1
    return s
end

-- Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯Ù…Ø¬ Ø¹Ù„Ù‰ Ø§Ù„Ø¶Ø­Ø§ÙŠØ§
local function mergeWithVictim(trainPlayer, victimPlayer)
    if not trainPlayer or not victimPlayer or not victimPlayer.Character then return end
    
    local victimChar = victimPlayer.Character
    local victimHumanoid = victimChar:FindFirstChildOfClass("Humanoid")
    local victimRoot = victimChar:FindFirstChild("HumanoidRootPart")
    
    if not victimHumanoid or not victimRoot then return end
    
    -- Ù‚ØªÙ„ Ø§Ù„Ø¶Ø­ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹
    victimHumanoid.Health = 0
    
    -- Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø¯Ù…Ø¬ Ù…Ø±Ø¦ÙŠ
    local mergeEffect = Instance.new("Part")
    mergeEffect.Name = "MergeEffect"
    mergeEffect.Size = Vector3.new(5, 5, 5)
    mergeEffect.Position = victimRoot.Position
    mergeEffect.Anchored = true
    mergeEffect.CanCollide = false
    mergeEffect.Material = Enum.Material.Neon
    mergeEffect.BrickColor = BrickColor.new("Bright red")
    mergeEffect.Transparency = 0.3
    mergeEffect.Parent = workspace
    
    local mesh = Instance.new("SpecialMesh", mergeEffect)
    mesh.MeshType = Enum.MeshType.Sphere
    
    -- ØªØ£Ø«ÙŠØ± ØµÙˆØªÙŠ Ù„Ù„Ø¯Ù…Ø¬
    local mergeSound = SFX(2767090, mergeEffect) -- ØµÙˆØª Ø§Ù†ÙØ¬Ø§Ø±
    mergeSound:Play()
    
    -- ØªÙˆÙ‡Ø¬ Ù…ØªØ²Ø§ÙŠØ¯ Ø«Ù… Ø§Ø®ØªÙØ§Ø¡
    spawn(function()
        for i = 1, 10 do
            mergeEffect.Transparency = mergeEffect.Transparency + 0.07
            mesh.Scale = mesh.Scale + Vector3.new(0.2, 0.2, 0.2)
            wait(0.05)
        end
        mergeEffect:Destroy()
    end)
    
    -- Ø±Ø³Ø§Ù„Ø© Ø¥Ø´Ø¹Ø§Ø±
    notifyPlayer(trainPlayer, "ğŸ”´ Merged with " .. victimPlayer.Name)
    
    print("ğŸ”´ " .. trainPlayer.Name .. " merged with " .. victimPlayer.Name)
end

-- Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¶Ø­Ø§ÙŠØ§ Ø¨Ø§Ù„Ù‚Ø±Ø¨ Ù…Ù† Ø§Ù„Ù‚Ø·Ø§Ø±
local function findNearbyVictims(trainPosition, radius)
    local nearbyVictims = {}
    local trainPlayer = Players.LocalPlayer
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= trainPlayer and player.Character then
            local victimRoot = player.Character:FindFirstChild("HumanoidRootPart")
            if victimRoot then
                local distance = (victimRoot.Position - trainPosition).Magnitude
                if distance <= radius then
                    table.insert(nearbyVictims, {
                        player = player,
                        distance = distance,
                        position = victimRoot.Position
                    })
                end
            end
        end
    end
    
    -- ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„Ø£Ù‚Ø±Ø¨
    table.sort(nearbyVictims, function(a, b)
        return a.distance < b.distance
    end)
    
    return nearbyVictims
end

-- Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯Ù…Ø¬ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ù„Ù…Ø³
local function setupMergeCollision(trainPart, trainPlayer)
    local debounce = false
    
    local touchConnection = trainPart.Touched:Connect(function(hit)
        if debounce then return end
        debounce = true
        
        if hit and hit.Parent then
            local victimModel = hit.Parent
            if victimModel:IsA("Model") then
                local victimPlayer = Players:GetPlayerFromCharacter(victimModel)
                if victimPlayer and victimPlayer ~= trainPlayer then
                    -- Ø¯Ù…Ø¬ ÙÙˆØ±ÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ù„Ù…Ø³
                    mergeWithVictim(trainPlayer, victimPlayer)
                    
                    -- ØªØ£Ø«ÙŠØ± Ø§Ù‡ØªØ²Ø§Ø² Ù„Ù„Ù‚Ø·Ø§Ø±
                    spawn(function()
                        local originalPosition = trainPart.Position
                        for i = 1, 5 do
                            trainPart.Position = trainPart.Position + Vector3.new(0, 0.2, 0)
                            wait(0.05)
                            trainPart.Position = originalPosition
                            wait(0.05)
                        end
                    end)
                end
            end
        end
        
        wait(0.3)
        debounce = false
    end)
    
    mergeConnections[trainPart] = touchConnection
end

-- Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯Ù…Ø¬ Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ (Ù„Ù…Ø³Ø§Ø­Ø© ÙƒØ¨ÙŠØ±Ø©)
local function massMerge(trainPosition, radius)
    local trainPlayer = Players.LocalPlayer
    local victims = findNearbyVictims(trainPosition, radius)
    
    for _, victimData in ipairs(victims) do
        mergeWithVictim(trainPlayer, victimData.player)
        wait(0.2) -- ØªØ£Ø®ÙŠØ± Ø¨ÙŠÙ† ÙƒÙ„ Ø¯Ù…Ø¬ Ù„Ù„Ø¯Ø±Ø§Ù…Ø§ØªÙŠÙƒÙŠØ©
    end
    
    return #victims
end

local function transformToTrain(character)
    if not character then return end
    
    local p = character
    local humanoid = p:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Store original state
    if not trainParts.originalTransparency then
        trainParts.originalTransparency = {}
        for i, v in pairs(p:GetChildren()) do
            if v:IsA("Part") then
                trainParts.originalTransparency[v] = v.Transparency
            elseif v:IsA("Accessory") then
                trainParts.originalTransparency[v] = true
            end
        end
    end
    
    -- Create train body
    local weld = Instance.new("Weld", p.Torso)
    weld.Part0 = p.Torso

    local train = Instance.new("Part", p.Torso)
    train.Name = "TrainBody"
    train.Anchored = false
    train.CanCollide = true
    train.Size = Vector3.new(4, 3, 8) -- Ø­Ø¬Ù… Ø£ÙƒØ¨Ø± Ù„Ù„Ø¯Ù…Ø¬
    train.Massless = true
    train.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
    train.BrickColor = BrickColor.new("Bright red")
    weld.Part1 = train
    weld.C1 = CFrame.new(0, 0, 0) * CFrame.Angles(0, math.rad(180), 0)
    
    local TrainMesh = Instance.new("SpecialMesh", train)
    TrainMesh.MeshType = Enum.MeshType.FileMesh
    TrainMesh.Scale = Vector3.new(0.025, 0.025, 0.020) -- Ø­Ø¬Ù… Ø£ÙƒØ¨Ø±
    TrainMesh.MeshId = "rbxassetid://431017802"
    TrainMesh.TextureId = "rbxassetid://431017809"

    -- Create smoke effect
    local weld2 = Instance.new("Weld", p.Torso)
    weld2.Part0 = p.Torso
    local Smoke = Instance.new("Part", p.Torso)
    Smoke.Name = "TrainSmoke"
    Smoke.Anchored = false
    Smoke.CanCollide = false
    Smoke.Size = Vector3.new(1, 1, 1)
    Smoke.Massless = true
    Smoke.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
    weld2.Part1 = Smoke
    weld2.C1 = CFrame.new(0, -4, 3.5)
    Smoke.Transparency = 1

    local Particle = Instance.new("ParticleEmitter", Smoke)
    Particle.Rate = 50
    Particle.Speed = NumberRange.new(30, 60)
    Particle.VelocitySpread = 4
    Particle.Texture = "rbxassetid://133619974"

    -- Create train light
    local Light = Instance.new("SpotLight", train)
    Light.Angle = 45
    Light.Brightness = 100
    Light.Face = Enum.NormalId.Back
    Light.Range = 30
    Light.Color = Color3.fromRGB(255, 0, 0) -- Ù„ÙˆÙ† Ø£Ø­Ù…Ø± Ù„Ù„Ø®Ø·Ø±

    -- Hide character parts
    for i, v in pairs(p:GetChildren()) do
        if v:IsA("Part") then
            v.Transparency = 1
        elseif v:IsA("Accessory") then
            v:Destroy()
        elseif v:IsA("Model") then
            v:Destroy()
        end
    end

    -- Increase speed
    spawn(function()
        while humanoid.Health > 0 and isTrainMode do
            humanoid.WalkSpeed = 80 -- Ø³Ø±Ø¹Ø© Ø£Ø¹Ù„Ù‰ Ù„Ù„Ø¯Ù…Ø¬
            wait()
        end
    end)

    -- Train sounds
    local Music = SFX(190819252, p.Torso)
    Music.Looped = true
    Music:Play()
    trainSounds.music = Music

    -- ğŸ”´ Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯Ù…Ø¬ Ø¹Ù„Ù‰ Ø§Ù„Ù„Ù…Ø³
    setupMergeCollision(train, Players.LocalPlayer)

    -- Ù†Ø¸Ø§Ù… Ø¯Ù…Ø¬ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ Ù„Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„ÙƒØ¨ÙŠØ±Ø©
    local massMergeConnection
    massMergeConnection = RunService.Heartbeat:Connect(function()
        if isTrainMode and train then
            -- Ø¯Ù…Ø¬ Ø¬Ù…Ø§Ø¹ÙŠ ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ Ù„Ù„Ù…Ø³Ø§Ø­Ø© 20 Ø¯Ø±Ø§Ø³Ø©
            local mergedCount = massMerge(train.Position, 20)
            if mergedCount > 0 then
                -- ØµÙˆØª Ø®Ø§Øµ Ø¹Ù†Ø¯ Ø§Ù„Ø¯Ù…Ø¬ Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ
                local massSound = SFX(911846833, p.Torso) -- ØµÙˆØª Ø¬Ù…Ø§Ø¹ÙŠ
                massSound:Play()
            end
            wait(5) -- Ø§Ù†ØªØ¸Ø§Ø± 5 Ø«ÙˆØ§Ù†ÙŠ Ø¨ÙŠÙ† ÙƒÙ„ Ø¯Ù…Ø¬ Ø¬Ù…Ø§Ø¹ÙŠ
        else
            massMergeConnection:Disconnect()
        end
    end)

    trainParts.weld = weld
    trainParts.weld2 = weld2
    trainParts.train = train
    trainParts.smoke = Smoke
    trainParts.particle = Particle
    trainParts.light = Light
    trainParts.massMergeConnection = massMergeConnection
    
    isTrainMode = true
    notifyPlayer(Players.LocalPlayer, "ğŸš‚ Train mode activated! ğŸ”´ MERGE SYSTEM ACTIVE")
end

local function revertFromTrain(character)
    if not character then return end
    
    local p = character
    local humanoid = p:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = 16 -- Reset to normal speed
    end
    
    -- Stop sounds
    for name, sound in pairs(trainSounds) do
        if sound and sound.Parent then
            sound:Stop()
            sound:Destroy()
        end
    end
    trainSounds = {}
    
    -- Ø¥ÙŠÙ‚Ø§Ù Ø§ØªØµØ§Ù„Ø§Øª Ø§Ù„Ø¯Ù…Ø¬
    for part, connection in pairs(mergeConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    mergeConnections = {}
    
    -- Remove train parts
    for name, part in pairs(trainParts) do
        if part and part.Parent then
            if name ~= "originalTransparency" then
                if name == "massMergeConnection" then
                    part:Disconnect()
                else
                    part:Destroy()
                end
            end
        end
    end
    
    -- Restore original appearance
    if trainParts.originalTransparency then
        for part, transparency in pairs(trainParts.originalTransparency) do
            if part and part.Parent then
                if part:IsA("Part") then
                    part.Transparency = transparency
                end
            end
        end
    end
    
    trainParts = {}
    isTrainMode = false
    notifyPlayer(Players.LocalPlayer, "ğŸ‘¤ Train mode deactivated")
end

local function toggleTrain(character)
    if isTrainMode then
        revertFromTrain(character)
    else
        transformToTrain(character)
    end
end

-- Ù†Ø¸Ø§Ù… Ø£Ù…Ø± Ø§Ù„Ø¯Ù…Ø¬ Ø§Ù„ÙŠØ¯ÙˆÙŠ
local function manualMerge(targetName)
    local trainPlayer = Players.LocalPlayer
    if not isTrainMode then
        notifyPlayer(trainPlayer, "âŒ You must be in train mode to merge!")
        return false
    end
    
    local targetPlayer = nil
    
    -- Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø§Ø³Ù…
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= trainPlayer then
            if player.Name:lower():find(targetName:lower()) or 
               (player.DisplayName and player.DisplayName:lower():find(targetName:lower())) then
                targetPlayer = player
                break
            end
        end
    end
    
    if targetPlayer then
        mergeWithVictim(trainPlayer, targetPlayer)
        return true
    else
        notifyPlayer(trainPlayer, "âŒ Player not found: " .. targetName)
        return false
    end
end

-- Command System
local function processCommand(player, message)
    local command = message:lower()
    
    if not checkCooldown(player) then return end
    
    if isOwner(player) then
        if command == "!t" then
            if player.Character then
                toggleTrain(player.Character)
            else
                notifyPlayer(player, "âŒ No character found!")
            end
            
        elseif command == "!train" then
            if player.Character then
                if not isTrainMode then
                    transformToTrain(player.Character)
                else
                    notifyPlayer(player, "ğŸš‚ Train mode is already active!")
                end
            end
            
        elseif command == "!untrain" then
            if player.Character then
                if isTrainMode then
                    revertFromTrain(player.Character)
                else
                    notifyPlayer(player, "ğŸ‘¤ Train mode is not active!")
                end
            end
            
        elseif command:sub(1, 7) == "!merge " then
            local targetName = command:sub(8)
            if targetName and targetName ~= "" then
                manualMerge(targetName)
            end
            
        elseif command == "!merge all" then
            if isTrainMode and trainParts.train then
                local mergedCount = massMerge(trainParts.train.Position, 100) -- Ù…Ø³Ø§Ø­Ø© ÙƒØ¨ÙŠØ±Ø©
                notifyPlayer(player, "ğŸ”´ Mass merged " .. mergedCount .. " players!")
            else
                notifyPlayer(player, "âŒ You must be in train mode!")
            end
            
        elseif command == "!help" then
            notifyPlayer(player, "ğŸš‚ Commands: !t, !train, !untrain, !merge [name], !merge all")
        end
        
    else
        if command == "!t" or command == "!train" or command:sub(1, 6) == "!merge" then
            notifyPlayer(player, "âŒ Only the owner can use train commands!")
        end
    end
end

-- Player Monitoring
local function monitorPlayer(player)
    player.Chatted:Connect(function(message)
        if message:lower():sub(1, 1) == "!" then
            processCommand(player, message)
        end
    end)
end

local function startMonitoring()
    for _, player in ipairs(Players:GetPlayers()) do
        monitorPlayer(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    monitorPlayer(player)
    if isOwner(player) then
        print("â­ Owner joined the game! (" .. _G.ControllerID .. ")")
        notifyPlayer(player, "ğŸ® You are the owner! Use !t to transform into a train")
    end
end)

-- Auto cleanup on death
game:GetService("RunService").Heartbeat:Connect(function()
    local player = Players.LocalPlayer
    if player and player.Character then
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.Health <= 0 and isTrainMode then
            revertFromTrain(player.Character)
        end
    end
end)

print("ğŸš‚ Train Merge System activated!")
print("â­ Owner ID: " .. _G.ControllerID)
startMonitoring()

local localPlayer = Players.LocalPlayer
if localPlayer and isOwner(localPlayer) then
    notifyPlayer(localPlayer, "ğŸš‚ Train system ready! Use !t to transform - ğŸ”´ MERGE ACTIVE")
end

return {
    activate = function() 
        print("Train Merge system activated!")
    end,
    
    transformToTrain = transformToTrain,
    revertFromTrain = revertFromTrain,
    toggleTrain = toggleTrain,
    manualMerge = manualMerge,
    massMerge = massMerge,
    
    isOwner = isOwner,
    isTrainMode = function() return isTrainMode end,
    
    getInfo = function()
        return {
            OwnerID = _G.ControllerID,
            IsTrainMode = isTrainMode,
            TotalPlayers = #Players:GetPlayers(),
            IsOwner = isOwner(Players.LocalPlayer)
        }
    end
}
